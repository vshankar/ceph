#!/usr/bin/python3

import sys
import curses
import errno
import json
import signal
import time

from collections import OrderedDict
from datetime import datetime
from enum import Enum, unique

import rados

class FSTopException(Exception):
    def __init__(self, msg=''):
        self.error_msg = msg

    def get_error_msg(self):
        return self.error_msg

@unique
class MetricType(Enum):
    METRIC_TYPE_NONE       = 0
    METRIC_TYPE_PERCENTAGE = 1
    METRIC_TYPE_LATENCY    = 2

FS_TOP_PROG_STR = 'fstop'
FS_TOP_PROG_VER = '0.0.1'

# version match b/w fstop and stats emitted by mgr/stats
FS_TOP_SUPPORTED_VER = 1

ITEMS_PAD_LEN = 1
ITEMS_PAD     = "  " * ITEMS_PAD_LEN

# metadata provided by mgr/stats
FS_TOP_MAIN_WINDOW_COL_CLIENT_ID = "CLIENT_ID"
FS_TOP_MAIN_WINDOW_COL_MNTPT     = "MOUNT_POINT"
FS_TOP_MAIN_WINDOW_COL_MNT_ROOT  = "MOUNT_ROOT"
FS_TOP_MAIN_WINDOW_COL_ADDR_HOST = "ADDR/HOST"

MAIN_WINDOW_TOP_LINE_ITEMS_START = [ITEMS_PAD,
                                    FS_TOP_MAIN_WINDOW_COL_CLIENT_ID,
                                    FS_TOP_MAIN_WINDOW_COL_MNTPT,
                                    FS_TOP_MAIN_WINDOW_COL_MNT_ROOT]
MAIN_WINDOW_TOP_LINE_ITEMS_END = [FS_TOP_MAIN_WINDOW_COL_ADDR_HOST]

# adjust this map according to stats version and maintain order
# as emitted by mgr/stast
MAIN_WINDOW_TOP_LINE_METRICS = OrderedDict([
    ("CAP_HIT"          , MetricType.METRIC_TYPE_PERCENTAGE),
    ("READ_LATENCY"     , MetricType.METRIC_TYPE_LATENCY),
    ("WRITE_LATENCY"    , MetricType.METRIC_TYPE_LATENCY),
    ("METADATA_LATENCY" , MetricType.METRIC_TYPE_LATENCY),
    ("DENTRY_LEASE"     , MetricType.METRIC_TYPE_PERCENTAGE),
])
MGR_STATS_COUNTERS = list(MAIN_WINDOW_TOP_LINE_METRICS.keys())

FS_TOP_VERSION_HEADER_FMT = '{prog_name} {prog_ver} - {now}'
FS_TOP_CLIENT_HEADER_FMT = 'Client(s): {num_clients} - {num_mounts} FUSE, {num_rest} kclient+libcephfs'

CLIENT_METADATA_KEY = "client_metadata"
CLIENT_METADATA_MOUNT_POINT_KEY = "mount_point"
CLIENT_METADATA_MOUNT_ROOT_KEY = "root"
CLIENT_METADATA_IP_KEY = "IP"
CLIENT_METADATA_HOSTNAME_KEY = "hostname"

GLOBAL_METRICS_KEY = "global_metrics"
GLOBAL_COUNTERS_KEY = "global_counters"

class FSTop(object):
    def __init__(self, client_name, cluster_name='ceph'):
        self.rados = None
        self.stop = False
        self.stdscr = None # curses instance
        self.client_name = client_name
        self.cluster_name = cluster_name

    def handle_signal(self, signum, _):
        self.stop = True

    def init(self):
        try:
            r_rados = rados.Rados(rados_id=self.client_name, clustername=self.cluster_name)
            r_rados.conf_read_file()
            r_rados.connect()
            self.rados = r_rados
        except rados.Error as e:
            if e.errno == errno.ENOENT:
                raise FSTopException(f'cluster {self.cluster_name} does not exist')
            else:
                raise FSTopException(f'error connecting to cluster: {e}')
        self.verify_perf_stats_support()
        signal.signal(signal.SIGTERM, self.handle_signal)
        signal.signal(signal.SIGINT, self.handle_signal)

    def fini(self):
        if self.rados:
            self.rados.shutdown()
            self.rados = None

    def selftest(self):
        stats_json = self.perf_stats_query()
        if not stats_json['version'] == FS_TOP_SUPPORTED_VER:
            raise FSTopException('perf stats version mismatch!')

    def setup_curses(self):
        self.stdscr = curses.initscr()

        # coordinate constants for windowing -- (height, width, y, x)
        # NOTE: requires initscr() call before accessing COLS, LINES.
        HEADER_WINDOW_COORD  = (2, curses.COLS - 1, 0, 0)
        TOPLINE_WINDOW_COORD = (1, curses.COLS - 1, 3, 0)
        MAIN_WINDOW_COORD    = (curses.LINES - 4, curses.COLS - 1, 4, 0)

        self.header = curses.newwin(*HEADER_WINDOW_COORD)
        self.topl = curses.newwin(*TOPLINE_WINDOW_COORD)
        self.mainw = curses.newwin(*MAIN_WINDOW_COORD)
        curses.wrapper(self.display)

    def verify_perf_stats_support(self):
        mon_cmd = {'prefix': 'mgr module ls', 'format': 'json'}
        try:
            ret, buf, out = self.rados.mon_command(json.dumps(mon_cmd), b'')
        except Exception as e:
            raise FSTopException(f'error checking \'stats\' module: {e}')
        if ret != 0:
            raise FSTopException(f'error checking \'stats\' module: {out}')
        if 'stats' not in json.loads(buf.decode('utf-8'))['enabled_modules']:
            raise FSTopException(f'\'stats\' module not enabled. Use \'ceph mgr module '\
                                 'enable stats\' to enable')

    def perf_stats_query(self):
        mgr_cmd = {'prefix': 'fs perf stats', 'format': 'json'}
        try:
            ret, buf, out = self.rados.mgr_command(json.dumps(mgr_cmd), b'')
        except Exception as e:
            raise FSTopException(f'error in \'perf stats\' query: {e}')
        if ret != 0:
            raise FSTopException(f'error in \'perf stats\' query: {out}')
        return json.loads(buf.decode('utf-8'))

    def mtype(self, typ):
        if typ == MetricType.METRIC_TYPE_PERCENTAGE:
            return "(%)"
        elif typ == MetricType.METRIC_TYPE_LATENCY:
            return "(s)"
        else:
            return ''

    def refresh_top_line_and_build_coord(self):
        x = xp = 0
        x_coord_map = {}

        heading = []
        for item in MAIN_WINDOW_TOP_LINE_ITEMS_START:
            heading.append(item)
            nlen = len(item) + len(ITEMS_PAD)
            x_coord_map[item] = (xp, nlen)
            xp += nlen

        for item,typ in MAIN_WINDOW_TOP_LINE_METRICS.items():
            it = f'{item}{self.mtype(typ)}'
            heading.append(it)
            nlen = len(it) + len(ITEMS_PAD)
            x_coord_map[item] = (xp, nlen)
            xp += nlen

        for item in MAIN_WINDOW_TOP_LINE_ITEMS_END:
            heading.append(item)
            nlen = len(item) + len(ITEMS_PAD)
            x_coord_map[item] = (xp, nlen)
            xp += nlen
        self.topl.addstr(0, 0, ITEMS_PAD.join(heading), curses.A_STANDOUT | curses.A_BOLD)
        return x_coord_map

    def calc_perc(self, c):
        if c[0] == 0 and c[1] == 0:
            return 0.0
        return round((c[0] / (c[0] + c[1])) * 100, 2)

    def calc_lat(self, c):
        return round(c[0] + c[1]/1000000000, 2)

    def refresh_client(self, client_id, metrics, counters, client_meta, x_coord_map, y_coord):
        for item in MAIN_WINDOW_TOP_LINE_ITEMS_END:
            coord = x_coord_map[item]
            if item == FS_TOP_MAIN_WINDOW_COL_ADDR_HOST:
                self.mainw.addstr(y_coord, coord[0],
                                  f'{client_meta[CLIENT_METADATA_IP_KEY]}/{client_meta[CLIENT_METADATA_HOSTNAME_KEY]}')
        for item in MAIN_WINDOW_TOP_LINE_ITEMS_START:
            coord = x_coord_map[item]
            if item == FS_TOP_MAIN_WINDOW_COL_CLIENT_ID:
                self.mainw.addstr(y_coord, coord[0], client_id.split('.')[1])
            elif item == FS_TOP_MAIN_WINDOW_COL_MNTPT:
                self.mainw.addstr(y_coord, coord[0], client_meta[CLIENT_METADATA_MOUNT_POINT_KEY])
            elif item == FS_TOP_MAIN_WINDOW_COL_MNT_ROOT:
                self.mainw.addstr(y_coord, coord[0], client_meta[CLIENT_METADATA_MOUNT_ROOT_KEY])
        cidx = 0
        for item in counters:
            coord = x_coord_map[item]
            m = metrics[cidx]
            typ = MAIN_WINDOW_TOP_LINE_METRICS[MGR_STATS_COUNTERS[cidx]]
            if typ == MetricType.METRIC_TYPE_PERCENTAGE:
                self.mainw.addstr(y_coord, coord[0], f'{self.calc_perc(m)}')
            elif typ == MetricType.METRIC_TYPE_LATENCY:
                self.mainw.addstr(y_coord, coord[0], f'{self.calc_lat(m)}')
            cidx += 1

    def refresh_clients(self, x_coord_map, stats_json):
        counters = [m.upper() for m in stats_json[GLOBAL_COUNTERS_KEY]]
        y_coord = 0
        for client_id, metrics in stats_json[GLOBAL_METRICS_KEY].items():
            self.refresh_client(client_id,
                                metrics,
                                counters,
                                stats_json[CLIENT_METADATA_KEY].get(client_id, {}),
                                x_coord_map,
                                y_coord)
            y_coord += 1

    def refresh_main_window(self, x_coord_map, stats_json):
        self.refresh_clients(x_coord_map, stats_json)

    def refresh_header(self, stats_json):
        if not stats_json['version'] == FS_TOP_SUPPORTED_VER:
            self.header.addstr(0, 0, f'perf stats version mismatch!')
            return False
        client_metadata = stats_json[CLIENT_METADATA_KEY]
        num_clients = len(client_metadata)
        num_mounts = len([client for client,metadata in client_metadata.items() if not \
                          metadata[CLIENT_METADATA_MOUNT_POINT_KEY] == 'N/A'])
        now = datetime.now().strftime('%H:%M:%S')
        self.header.addstr(0, 0, FS_TOP_VERSION_HEADER_FMT.format(
            prog_name=FS_TOP_PROG_STR, prog_ver=FS_TOP_PROG_VER, now=now),
                           curses.A_STANDOUT | curses.A_BOLD)
        self.header.addstr(1, 0, FS_TOP_CLIENT_HEADER_FMT.format(
            num_clients=num_clients, num_mounts=num_mounts, num_rest=num_clients - num_mounts))
        return True

    def display(self, _):
        x_coord_map = self.refresh_top_line_and_build_coord()
        self.topl.refresh()
        while not self.stop:
            stats_json = self.perf_stats_query()
            self.header.clear()
            self.mainw.clear()
            if self.refresh_header(stats_json):
                self.refresh_main_window(x_coord_map, stats_json)
            self.header.refresh()
            self.mainw.refresh()
            time.sleep(1)

if __name__ == '__main__':
    err = False
    ft = FSTop('fstop')
    try:
        ft.init()
        if len(sys.argv) > 1 and sys.argv[1] == "--selftest":
            ft.selftest()
            print("selftest ok")
        else:
            ft.setup_curses()
    except FSTopException as fst:
        err = True
        print(f'{fst.get_error_msg()}')
    except Exception as e:
        err = True
        print(f'exception: {e}')
    finally:
        ft.fini()
    sys.exit(0 if err == False else -1)
